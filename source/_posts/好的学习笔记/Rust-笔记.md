---
title: 笔记-Rust
categories: 好的学习笔记
tags: Rust
banner_img: https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230919145002692.png
---



# Rust 笔记

### 前提
* [参考书: rust语言圣经](https://course.rs/about-book.html)

* [参考书: rust之旅](https://github.com/HnglngWng/Programming_Rust-zh-cn/blob/master/ch02-Rust%E4%B9%8B%E6%97%85.md)




Rust 是一种多范式的编程语言，它既支持面向对象编程（OOP）的概念，也支持面向过程编程（Procedural Programming）。开发者使用不同的编程范式来满足特定需求。



**首先请谨记以下所有权规则**：

* Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
* 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
* 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)




---


# 基本数据类型

> Rust 的数值类型和运算跟其他语言较为相似

- 【Rust 拥有相当多的数值类型】

   因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数

  

- 【类型转换必须是显式的】

  Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数

  

- 【Rust 的数值上可以使用方法】

  例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`，在这里我们使用了类型后缀，因为编译器需要知道 `13.14` 的具体类型



# 基本数据类型（其它）

1、字符类型

* char，4个字节

2、布尔类型

* bool，1个字节

3、单元类型

* ()，可以作为一个值用来占位，但是完全不占用任何内存



# 复合数据类型

### 结构体

#### 1、结构体初始化

* 初始化实例时，每个字段都需要进行初始化
* 初始化时的字段顺序不需要和结构体定义时的顺序一致



#### 2、元组结构体

结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体

![image-20230510135528843](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510135528843.png)

元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。例如上面的 `Point` 元组结构体，众所周知 3D 点是 `(x, y, z)` 形式的坐标点，因此我们无需再为内部的字段逐一命名为：`x`, `y`, `z`。



#### 3、单元结构体

单元结构体就跟它很像，没有任何字段和属性，但是好在，它还挺有用。

![image-20230510135653737](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510135653737.png)

如果你定义一个类型，但是不关心该类型的内容, 只关心它的行为时就可以使用它了。



### 枚举

> 枚举类型是一个类型，它会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员的实例



#### 1、枚举值

下面是一个不带值的枚举类型，和其它语言类似。

![image-20230510140554100](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510140554100.png)

通过 `PokerSuit::Hearts` 获取的值就是 `枚举值`，它是枚举类型里Hearts的实例。

![image-20230510140724104](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510140724104.png)

这个好处是什么呢？如果定义返回值是枚举类型，那么它的返回值可以是枚举里的任意一个 `变体` 。也就是说通过一个枚举类型可以实现多种类型的接收，而结构体是无法接收不同结构体的。详情看【同一化类型】



#### 2、带有值的枚举值

前面的枚举是没有值的，如果想要让枚举带有值，实现方式如下：

**实现方式一：**

通过结构体代替，结构体中定义两个字段，枚举类型和枚举值

![image-20230510141426185](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510141426185.png)



**实现方式二：**

通过结构体是可以实现，但是不优雅，其实 Rust 的枚举支持直接将数据信息关联到枚举成员上(`变体`)。

![image-20230510141748471](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510141748471.png)



#### 3、带有值的枚举值（任何类型）

> 当然了，Rust 枚举的一大特定就是，枚举的任何类型的数据都可以放入枚举成员中，例如字符串、数值、结构体甚至另一个枚举。



![image-20230510142204204](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510142204204.png)



#### 4、同一化类型

​	如果定义返回值是枚举类型，那么它的返回值可以是枚举里的任意一个 `变体` 。也就是说通过一个枚举类型可以实现多种类型的接收，而结构体是无法接收不同结构体的。

![image-20230510143010386](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510143010386.png)



#### 5、Option 枚举

其它高级语言运行了 Null 的存在，所以会造成空指针异常。Rust 对这个做出了调整，它决定抛弃 `null`，而改为使用 `Option` 枚举变量来表述这种结果。

其中 `Option` 枚举包含两个成员，一个成员表示含有值：`Some(T)`, 另一个表示空：`None`，定义如下：

![image-20230511140614210](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230511140614210.png)



在声明变量的时候，我们需要常常声明变量类型为 `Option` 来表示改变量是允许为空值的。如下：

![image-20230511141840451](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230511141840451.png)



可以看到 absent_number 显示声明了类型，这是因为使用 Some(5) 编译器是能确定 `Option<T>` 的实际类型是 `Option<5>`， 但是如果是 None，它是没办法推断出来的，所以需要显示声明。





在对 `Option<T>` 进行 `T` 的运算之前必须将其转换为 `T`。通常这能帮助我们捕获到空值最常见的问题之一：期望某值不为空但实际上为空的情况。如下：

![image-20230511142303722](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230511142303722.png)

Rust 对如上代码是不允许编译通过的，根本原因就是 x 和 y 的类型是不一样的，所以使用 `Option<T>` 时必须进行类型转换，而这转换的过程就必须要考虑对空值情况的处理。如下所示：

![image-20230511142939847](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230511142939847.png)





### 数组

在 Rust 中，最常用的数组有两种，第一种是速度很快但是长度固定的 `array`，第二种是可动态增长的但是有性能损耗的 `Vector`

* 数组 `array` 是存储在栈上，性能也会非常优秀。
* 动态数组 `Vector` 是存储在堆上，因此长度可以动态改变。



#### 1、array 数组

数组的具体定义很简单：将多个类型相同的元素依次组合在一起，就是一个数组。结合上面的内容，可以得出数组的三要素：

- 长度固定
- 元素必须有相同的类型



#### 2、Vector 数组

动态数组只能存储相同类型的元素，如果你想存储不同类型的元素，可以使用之前讲过的 `枚举类型` 或者 `特征对象`。

如下所示。`IpAddr::V4` 和 `IpAddr::V6` 是同一个枚举类型的枚举值，所以是允许的。

![image-20230510150420956](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510150420956.png)







`特征对象` 实现存储不同类型元素的数组的方式与智能指针Box有关，后面【特征对象和Box智能指针】处有介绍...............................



# 变量和常量（新概念：可变和不可变）

【问题】：为什么要设置变量得不可变，是出于什么考虑才这样设计？

![image-20230506173151988](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230506173151988.png)



【问题】：那有哪些编程语言的变量是不可以变的，有哪些是可变的？

![image-20230506173615985](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230506173615985.png)



【问题】：不可变变量和常量的区别是什么？

* 不可变变量一旦为它绑定值，就不能再修改。
* 常量是至终不可变，常量可以在任意作用域内声明，包括全局作用域。

~~~rust
// 5可以被绑定到变量x上，但是由于x是不可变的，x不能修改绑定，所以6不能绑定到x上。
fn main() {
    let x = 5;
    x = 6;	// 提示错误
}

// 第二个x是新的变量，第一个x会被第二个x【遮蔽】
fn main() {
    let x = 5;
    let x = 6;	// 正确
}
~~~





# 所有权（关键）

【绑定】就是把这个对象绑定给一个变量，让这个变量成为它的主人，那么原主人也理所当然所有权。

【借用】的方式，将对象借给别人，此时所有权依然还是自己。



### 栈(Stack)与堆(Heap)

**栈内存有以下特点：**

* 栈中的所有数据都必须占用已知且固定大小的内存空间
* 栈内存申请和释放是非常高效的



【问题】为什么说栈内存申请和释放是非常高效的？

* 在函数调用时会在其中创建一个临时栈空间，调用结束后 Rust 会让这个栈空间里的对象自动进入 `Drop` 流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预，因而栈内存申请和释放是非常高效的。



### 基本类型的拷贝、复合类型的移动、复合类型深拷贝

基本类型比较简单，存储在栈内存上。对于基本类型，Rust 会自动拷贝。

复合类型比较复杂，存储在堆和栈上。对于复合类型，往往是由 `存储在栈中的:堆指针、字符串长度、字符串容量`和 `存储在堆中的字符串内容`  共同组成。Rust不会自动拷贝。这里的自动拷贝指的是【Rust 永远也不会自动创建数据的 “深拷贝”】。但是 Rust 会进行【移动】。



【问题】什么叫复合类型的移动？

* 复合类型比较复杂，所以”自动拷贝“只会是拷贝存储在栈上的数据。

* 对于拷贝指针、长度和容量而不拷贝数据听起来就像”浅拷贝“，但是又因为 Rust 同时使第一个变量无效了，因此这个操作并不是浅拷贝，而是被称为【移动】。



如以下例子所示，基本类型的拷贝和复合类型深拷贝是拷贝了一份完整的数据，也就是说产生了一个对象给到了新的所有者，所以新旧所有者直接没有所有权转交的问题。

但是对于复合类型的移动之前，它们是共享一份堆内存数据的，由于【所有权原则中的：一个值只允许有一个所有者】，所以移动之后所有权发生了转移，前者也就失效了，所以 15 行处调用失效的 s1 变量时编译报错了。

![image-20230509181425537](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509181425537.png)





###  Drop trait

【问题】为什么变量离开作用域范围时，这个值将被丢弃？

![image-20230506183851110](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230506183851110.png)



【问题】Rust 什么情况下，会自动调用该变量的 drop 方法？

* 当一个变量离开其声明的作用域时
* 当一个变量被重新绑定或移动所有权时
* 某些情况下，可以使用 `std::mem::drop` 函数手动调用变量的 `drop` 方法



【问题】所有变量都实现了Drop trait吗？

![image-20230506184915337](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230506184915337.png)





### Copy trait

>  当类型实现了Copy trait 时，可以通过赋值操作符直接对该类型的值进行复制，而不会发生所有权转移。

任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的：

- 所有整数类型，比如 `u32`
- 布尔类型，`bool`，它的值是 `true` 和 `false`
- 所有浮点数类型，比如 `f64`
- 字符类型，`char`
- 元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 就不是
- 不可变引用 `&T` 。



对比以下两处：

* 对于复合类型，赋值操作后 s1 进行了【移动】操作。所以 s1 已经将所有权转交给了 s2。
* 对于不可变引用，赋值操作后 x 进行了【浅拷贝】操作。y 通过该操作只是借用了 x，没有发生所有权转移。

``` rust
fn main() {
    let s1 = String::from("hello");
	let s2 = s1;
	println!("{}, world!", s1);	// s1 报错，s1 已经失效，这里是无效引用
}

fn main() {
    let x: &str = "hello, world";
    let y = x;
    println!("{},{}",x,y);	// 正常
}
```



如果仅仅支持通过转移所有权的方式获取一个值，那会让程序变得复杂。借用是另外一种方式，“借来用一下”。



### 引用和借用（新概念：借用）

> 借用并不改变所有权。借用是一种临时的操作，它允许我们在特定的作用域中对值进行引用，而不会获取其所有权。

Rust 能否像其它编程语言一样，使用某个变量的指针或者引用呢？答案是可以，借用。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主。



* 引用符号：`&`
* 可变引用符号：`&mut`
* 解引用符号：`*` 



![image-20230508145021525](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508145021525.png)



**注意：**

 可变引用可以允许你在借用的情况下修改值，但是Rut为了贯彻【防止同时修改同一数据】的原则，【同一作用域内】：

* 特定数据只能有一个可变引用

  ![image-20230508150423586](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508150423586.png)

* 可变引用与不可变引用不能同时存在

  ![image-20230508150454920](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508150454920.png)

引用的作用域和变量的作用域不一样。引用的作用域从创建开始，一直持续到它最后一次使用的地方，变量的作用域从创建持续到某一个花括号 `}`。



### 悬垂引用

上面介绍的所有权的借用，可能因为不注意会经常发生悬垂引用的问题。



**什么是悬垂引用呢？**

* 悬垂引用也叫做悬垂指针，意思为指针指向某个值后，之后这个值被释放掉了，而指针仍然存在但是指向的值不存在了。



但是放心，如果存在悬垂引用，Rust 会抛出一个编译时错误。

![image-20230508151502640](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508151502640.png)

### Deref trait 和自动转换

Defef trait 有两个作用：通过实现 Deref trait，可以使一个类型在被解引用时表现得像另一个类型。

1. 自动解引用转换
2. 重载实现自定义转换



#### 1、自动解引用转换

通过实现 Defef trait 实现的自动解引用，可以直接操作引用所指向的值，而无需手动使用 `*` 运算符进行解引用。

> 自动解引用相当于隐式调用了Defef trait 里的 defef() 方法，返回的是一个指向内部数据的引用。



#### 2、重载实现自定义转换

和 From trait、Into trait 一样，都可以通过重载实现自定义功能。



# 所有权、生命周期和引用（关键）

​	上面介绍所有权里的【引用和借用】的时候，涉及到的 `引用` 的作用域就是这里声明周期要介绍的。【同一作用域内特定数据只能有一个可变引用】、【悬垂引用】等注意点。



**什么是声明周期？**

* 生命周期，简而言之就是 `引用` 的有效作用域。
* 在大多数时候，我们无需手动的声明生命周期，因为编译器可以自动进行推导。
* 当编译器无法自动推导出来时，就需要手动标注。



【问题】为什么要进行手动标注呢？

* 不同参数以及返回值之间的生命周期的。一旦它们取得了某种联系，Rust 也就获得了足够的信息来保障内存安全的操作并且阻止那些违反内存安全的行为。
* 简而言之，就是，Rust 编译器需要知道更多的信息来确定代码是内存安全的，但是有些“复杂”情况它识别不了，所以通过提示你手动标注之后，它才能完成安全检查。



【问题】什么时候编译器无法自动推导，然后需要手动进行标注呢？

![image-20230508220115384](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508220115384.png)



### 借用检查

可以参考一下可视化图理解借用检查。

![image-20230508183813439](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508183813439.png)



![image-20230508183859634](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508183859634.png)



### 函数中的声明周期

先看下面例子，乍一看好像没什么问题。现实是会编译报错的喔。

![image-20230508200643093](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508200643093.png)

![image-20230508200732734](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508200732734.png)







### 生命周期标注语法

首先非常重要的一点是，生命周期标注并不会改变任何引用的实际作用域。它只是为了帮助“不聪明的” Rust 编译器。

* 标注符号：`'a`
* 可变：`&'a` 
* 不可变：`&'amut`



### 函数的生命周期

**需要注意的**：

* 指定生命周期参数的方式依赖于函数所做的事情
* 函数返回值是 `引用` 类型时，返回的生命周期需要与其中一个参数的生命周期匹配
* 如果不指向参数中的一个，指向的是局部变量的 `引用`，就会发生【垂直引用】

![image-20230508222746575](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508222746575.png)



![image-20230508222947766](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508222947766.png)





【问题】怎么确定函数返回值的生命周期？

* 当可能出错也可能不出错时，它会选择前者，抛出编译错误。
* 简而言之，就是，它会选择多个参数之间生命周期最小的。



### 生命周期消除

​	前面说到，很多情况下Rust都能自动标注生命周期，所以也就是为什么到了这一章才在函数中看到 `'a` 这个”奇怪“的语法了，因为Rust运用了许多【消除大法】帮我们做了很多工作。



**三条消除法则：**

1. 每一个引用参数都会获得独自的生命周期。
2. 若只有一个输入生命周期，那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期。
3. 若存在多个输入生命周期，且其中一个是 `&self` 或 `&mut self`，则 `&self` 的生命周期被赋给所有的输出生命周期。(只适用于方法的生命周期)



**例子1：**

~~~ rust
fn first_word(s: &str) -> &str { // 实际项目中的手写代码

fn first_word<'a>(s: &'a str) -> &str { // 首先根据第一条：编译器自动为参数添加生命周期
    
fn first_word<'a>(s: &'a str) -> &'a str { // 接着根据第二条：编译器自动为返回值添加生命周期
    
// 获得了完整的信息，编译通过
~~~



**例子2：**

~~~rust
fn longest(x: &str, y: &str) -> &str { // 实际项目中的手写代码
 
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str { // 首先根据第一条：编译器自动为参数添加生命周期
    
// 第二条规则却无法被使用，因为输入生命周期有两个，第三条规则也不符合，因为它是函数
// 没有完整的信息，编译失败
~~~



### 结构体和方法的生命周期

​	不仅仅函数具有生命周期，结构体和方法其实也有这个概念。

​	只不过我们之前对结构体的使用都停留在非引用类型字段上。为什么钟爱使用【非引用字段】呢？还不是因为不是引用，也就意味着没有生命周期的约束，可以直接转交所有权，可以为所欲。

如下例子，如果结构体中包含了 `引用` 类型，那就必须要手动标注声明周期，保证改引用值必须获得比结构体久。

![image-20230512154019616](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512154019616.png)

如下，如果在标注了声明周期的情况下，如果结构体活得比较久，结构体中的引用提前被清除，就会编译异常。![image-20230512154426372](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512154426372.png)





### 静态生命周期

​	在 Rust 中有一个非常特殊的生命周期，那就是 `'static`，拥有该生命周期的引用可以和整个程序活得一样久。

这时可能会联想到字符串字面量，因为它就是活得很久。其实它就是拥有static的生命周期：

~~~ rust
let s: &'static str = "我没啥优点，就是活得久，嘿嘿";
~~~



​	所以，在你十分自信的时候，将生命周期生命为 static 吧，这样就可以解决编译不通过的问题了，但是问题来了：本来该引用没有活那么久，但是你非要说它活那么久，万一引入了潜在的 BUG 怎么办？



# 函数和方法

> 方法和结构体有关，他和结构体名称相同。它的第一个参数往往是 `self`。

使用方法代替函数有以下好处：

- 不用在函数签名中重复书写 `self` 对应的类型。
- 代码的组织性和内聚性更强，对于代码维护和阅读来说，好处巨大



### Self

在一个 `impl` 块内，`Self` 指代被实现方法的结构体类型，`self` 指代此类型的实例

* `&self` 其实是 `self: &Self` 的简写（注意大小写）
* `self` 表示所有权转移到该方法中，这种形式用的较少
* `&self` 表示不可变借用
* `&mut self` 表示可变借用

![image-20230508171219264](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230508171219264.png)



### 关联函数

> 在 `impl` 中且没有 `self` 的函数被称之为关联函数。因为它没有 `self`，不能用 `f.read()` 的形式调用，因此它是一个函数而不是方法，它又在 `impl` 中，与结构体紧密关联。





# 表达式

### 前提

> [表达式(Expressions)](https://github.com/HnglngWng/Programming_Rust-zh-cn/blob/master/ch06-%E8%A1%A8%E8%BE%BE%E5%BC%8F.md)

* C 中的大多数控制流工具都是语句，在Rust中,它们都是表达式。
* Rust是所谓的表达式语言，这意味着它遵循较古老的传统,可追溯到Lisp，其中表达式完成所有工作。Lisp 被认为是最早的函数式编程语言之一。



### 表达式和语句

* 能返回值，它就是表达式。
* 表达式不能包含分号。一旦你在表达式后加上分号，它就会变成一条语句，再也不会返回一个值。







# 函数

### 前提

**零长度元组**：

* 单元类型 `()`，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值



### 函数参数

 Rust 是强类型语言，因此需要你为每一个函数参数都标识出它的具体类型。

![image-20230506165138029](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230506165138029.png)



【问题】什么时候需要手动声明类型呢？

![image-20230509112426302](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509112426302.png)



### 函数返回

#### 1、可以同时使用 `return` 和表达式作为返回值

![image-20230506170044008](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230506170044008.png)



#### 2、无返回值()

- 函数没有返回值，那么隐式返回一个 `()`
- 通过 `;` 结尾的表达式隐式返回一个 `()`

![image-20230506170612665](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230506170612665.png)

在实际编程中，你会经常在错误提示中看到该 `()` 的身影出没。因为你没有注意正确的返回值。



#### 3、永不返回的发散函数 

使用`!`标识函数的返回值时，表示它是一个发散函数，它是永远不返回的。

~~~ rust
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}
~~~



# 泛型

在开始讲解 Rust 的泛型之前，先来看看什么是多态。

在编程的时候，我们经常利用多态。通俗的讲，多态就是好比坦克的炮管，既可以发射普通弹药，也可以发射制导炮弹（导弹），也可以发射贫铀穿甲弹，甚至发射子母弹，没有必要为每一种炮弹都在坦克上分别安装一个专用炮管，即使生产商愿意，炮手也不愿意，累死人啊。所以在编程开发中，我们也需要这样“通用的炮管”，这个“通用的炮管”就是多态。

实际上，泛型就是一种多态。泛型主要目的是为程序员提供编程的便利，减少代码的臃肿，同时可以极大地丰富语言本身的表达能力，为程序员提供了一个合适的炮管。



下面使用简单例子过一些泛型的使用

### 结构体泛型

![image-20230509000139562](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509000139562.png)



### 枚举泛型

![image-20230509000000827](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509000000827.png)



### 方法泛型

（不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解不理解）

![image-20230509000535391](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509000535391.png)



方法泛型需要注意两点：

* 需要声明两处，`Point<T> 和 impl<T>` ，这样 Rust 才知道 `Point` 的尖括号中的类型是泛型而不是具体类型

* 方法里面的函数也可以定义为泛型

  ![image-20230509001004613](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509001004613.png)





# 返回值和错误处理

​	如何正确处理错误，这是保证程序完整的重要一环。Rust 使用 `panic`，翻译为“恐慌”来处理异常。 



### panic 和不可恢复错误

​	当前线程发生恐慌后，线程就会终止。所以因此，尽量不要在 `main` 线程中做太多任务，将这些任务交由子线程去做，就算子线程 `panic` 也不会导致整个程序的结束。



当然了，我们时不能百分百保证程序不发生恐慌，所以也就相应会有【异常处理】的操作。



### Result 和可恢复错误

常常会使用 `Result<T, E>` 来代替恐慌，很多系统封装都是使用该类型作为返回值，可以返回调用成功或失败的值。

![image-20230509134849419](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509134849419.png)



![image-20230509140210152](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509140210152.png)



**1、处理方式一**

后续可以拿到该值进行业务处理，比如如果失败了，就自己再去主动恐慌。如下所示：

通过 match 匹配，如果匹配到了返回值里的 Err(E) 类型，就主动恐慌。因为恐慌是直接中断程序的，所以这里 match 的返回值不存在多个这一错误说法。

![image-20230509135335027](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509135335027.png)



**2、处理方式二**

当然，上面方式一还可以后更复杂的处理，但是如果只是和方式一一样，简单的抛出恐慌的话，Rust 提供了效果相同两个方法：

* unwrap
* expect



![image-20230509140447582](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509140447582.png)





![image-20230509140534719](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509140534719.png)





### 传播错误

上面说到，尽量不要在主线程里处理太多业务，万一恐慌了整个程序也就中断了。但是呢？有时候还是需要将子程序的恐慌交会给父程序的。



如何做到的，通过需要自定义返回类型实现？



**1、处理方式一**

比如 `Result<String, io::Error>`，就代表成功时，返回 `Ok(String)`，失败时，返回 `Err(io:Error)`。



![image-20230509142645700](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509142645700.png)



**2、处理方式二**

Rust依然为这些复杂但是又常用的处理进行了封装，使用 `?` 可以直接传播异常。

可以看到，使用 `？` 可以直接 return 异常，不再需要 match 匹配。

![image-20230509143147930](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509143147930.png)



下面继续深入了解这个传播错误的宏，为什么要选择它。



### 传播错误运算符?

​	首先，如果我们使用 match 匹配，必须要做到返回值对应，即使返回类型之间存在上下级关系，也是不行的也会报错。例如：

例如标准库中的 `std::io::Error `和 `std::error::Error`，前者是 IO 相关的错误结构体，后者是一个最最通用的标准错误特征，同时前者实现了后者，因此 `std::io::Error` 可以转换为 `std:error::Error` 才对。

但是在match匹配中不行，它需要一一对应，而不会帮你自动转换。如下：

![image-20230509144133153](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509144133153.png)

但是呢，`传播错误运算符` 可以！！！！！！！！！

它能帮你自动转换，所以以后你不需要考虑那么多返回类型的问题啦，只需要将父类型当返回值就可以了。如下所示：

![image-20230509144357969](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509144357969.png)

【问题】为什么 `传播错误的运算符` 能帮我们自动转换类型呢？

* 根本原因是在于标准库中定义的 `From trait` ，该特征有一个方法 `from`，用于把一个类型转成另外一个类型

* `?` 可以自动调用该方法，然后进行隐式类型转换。

* 后续章节详细学习【From trait】

  ![image-20230509145036505](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509145036505.png)



### 传播错误运算符和Option

`传播错误的运算符` 不仅仅可以用于 `Result` 的传播，还能用于 `Option` 的传播， `Option` 通过 `?` 返回 `None`

![image-20230509150028966](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509150028966.png)

![image-20230509150307987](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509150307987.png)



> 这里，你可能也注意到了。每次使用 `传播错误的运算符 ` 都需要编写函数正确的返回值，如 【Some(v)、Ok(s)】等，这是因为它只有错误值能直接返回，正确的值不行。



此时引发一个问题，如果是 main 函数里使用 `传播错误的运算符` ，那 main 函数也需要返回值咯？

### 传播错误运算符和main函数

由于此处 main 函数没有返回值，所以使用 `传播错误运算符` 显然是会编译报错的，如下所示。

![image-20230509155055314](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509155055314.png)

在我们认知中，main 函数是没有返回值的，但是 Rust 却是支持另外一种形式的 main 函数——【有返回值的 main 函数】。

![image-20230509155437642](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509155437642.png)

【问题】为什么 main 函数可以实现有错误返回值，它是怎么实现的？

* 因为 `std::error:Error` 是 Rust 中抽象层次最高的错误，其它标准库中的错误都实现了该 trait，因此我们可以用该特征对象代表一切错误，就算 `main` 函数中调用任何标准库函数发生错误，都可以通过 `Box<dyn Error>` 这个 trait 对象进行返回。
* 后续章节详细学习【Box 智能指针】



# From trait

​	前面【传播错误运算符？】中，提到了它使用到了`From trait`，实现了错误类型的自动转换。

​	在 Rust 的标准库中，`From trait` 用于定义类型间的转换。它提供了一种标准化的方式来从一个类型转换为另一个类型，使类型转换变得更加方便和灵活。

​	这种转换可以用于多种场景，例如类型的初始化、类型的转换、类型的组合等。下面举个类型转换的例子：

目标是将坐标 `(3, 5)` 转换为 `Point struct` 类型，如下所示



![image-20230509145622795](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230509145622795.png)



# Debug trait 和 Display trait

这两个 trait 是格式化输出必须实现的。其中 Rust 中的绝大多数类型都实现了 Debug，但是 Display 就需要手动实现。

- `{}` 适用于实现了 `std::fmt::Display` 特征的类型，用来以更优雅、更友好的方式格式化文本。
- `{:?}` 适用于实现了 `std::fmt::Debug` 特征的类型，用于调试场景。



### Debug trait 和 Display trait

如下所示。

![image-20230619151623591](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230619151623591.png)



或者更加详细。如下所示。

![image-20230619152955933](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230619152955933.png)



### 简化错误处理和 thiserror

很多的类型需要自己手动实现 Display trait 和 From trait。这使得错误处理中的代码需要费多一点心思。于是我们可以选择【thiserror crate】工具。

如下所示，只要简单写写注释，就可以实现错误处理了。

![image-20230619153902073](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230619153902073.png)



# 智能指针

在之前的章节中，实际上我们已经见识过多种智能指针。例如：

* 动态字符串 `String` 
* 动态数组 `Vec`



它们的数据结构中不仅仅包含了指向底层数据的指针，还包含了当前长度、最大长度等信息，其中 `String` 智能指针还提供了一种担保信息：所有的数据都是合法的 `UTF-8` 格式。

~~~
智能指针 = 指针 + 担保信息
~~~



该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行【计数】，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。



【问题】为什么出现智能指针？

* Rust 的编译器之严格，可以说是举世无双。特别是在所有权方面，Rust 通过严格的规则来保证所有权和借用的正确性，最终为程序的安全保驾护航。
* 但是严格是一把双刃剑，带来安全提升的同时，损失了灵活性，有时甚至会让用户痛苦不堪、怨声载道。



下面是 Rust 通过智能指针“违背” Rust 所有权规则的地方：

| Rust 规则                            | 智能指针带来的额外规则                  |
| ------------------------------------ | --------------------------------------- |
| 一个数据只有一个所有者               | `Rc/Arc`让一个数据可以拥有多个所有者    |
| 要么多个不可变借用，要么一个可变借用 | `RefCell`实现编译期可变、不可变引用共存 |
| 违背规则导致**编译错误**             | 违背规则导致**运行时`panic`**           |



智能指针的设计实现了两个关键 trait：Deref trait 和 Drop trait

* 智能指针往往是基于结构体实现
* 与自定义的结构体最大的区别在于它实现了 `Deref trait` 和 `Drop trait` 



### 指针、引用和智能指针（重要）

* 指针是一种底层的、不安全的访问方式，直接操作内存地址，需要手动管理所有权和生命周期。
* 引用是一种安全的、受限制的访问方式，遵循 Rust 的借用规则，进行编译时的所有权和生命周期检查。在 Rust 中，最常见的指针类型是引用，引用在 Rust 中被赋予了更深层次的含义——【借用其它变量的值】。
* 智能指针是一种具有所有权和生命周期管理功能的指针类型。它们是 Rust 中更为常见的指针类型。



**智能指针有哪些：**

* Box，可以将值分配到堆上
* Rc，引用计数类型，允许多所有权存在
* Arc
* RefCell 等



### 堆栈数据拷贝的效率

​	根据 [堆栈性能分析](https://course.rs/advance/smart-pointer/box.html) 的结论，对于不同大小的数据，栈的读取数据不一定高于堆。因此不要仅仅因为堆上性能不如栈这个印象，就总是优先选择栈，导致代码更复杂的实现。

​	如下例子所示，在当需要创建的数据较为大时，在栈中自动拷贝的效率是不一定会大于堆中自动拷贝的。根据前面【基本类型的拷贝、复合类型的移动、复合类型深拷贝】的介绍，对于复合类型的自动拷贝，Rus t只会拷贝起存放在栈中的堆指针，这个指针的大小必然是小于我们这里的数组。

![image-20230510103705386](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510103705386.png)



### Box 智能指针

​	上面例子可以看到，我们如果需要将大数组存放到堆中，就可以使用 `Box::new([0;1000])` 实现。正如我们使用的一样，Box 的功能就是值存储在堆上，Box 相比其它智能指针，功能较为单一。

**使用场景如下：**

- 特意的将数据分配在堆上
- 类型的大小在编译期无法确定，但是我们又需要固定大小的类型时
- 当你有大量数据，只想移交所有权，但是需要确保在操作时数据不会被复制
- 特征对象，用于说明对象实现了一个特征，而不是某个特定的类型（没理解）



【问题】怎么理解“类型的大小在编译期无法确定，但是我们又需要固定大小的类型时”？

为了回答这个问题，继续往下.....................



### 递归和确定类型空间大小

> 在编译时，Rust 需要知道一个类型所占空间的大小，但是递归类型的大小无法在编译时确定



【问题】Rust 如何确定【非递归类型】的空间大小呢？

* 对于基本类型，它们的大小是固定的，由其具体的类型决定。
* 对于复合类型中的结构体，它等于所有成员大小的总和。
* 对于复合类型中的枚举，它的等于最大 `变体` 的大小。



【问题】为什么枚举类型的大小不是所有变体的大小的总和呢？

* 枚举类型的大小不是所有变体的大小的总和，是因为枚举类型的不同 `变体`之间是互斥的，即一个枚举实例只能是其中一个变体中的一种，而不能同时属于多个变体，因此枚举类型的大小只需要足够大，能够容纳其中最大的变体即可。
* 例如一个拥有两个变体的枚举类型，如果其中一个变体是一个字节大小的整数，另一个变体是一个 8KB 的字符串，则这个枚举类型的大小就是 8KB，因为这足以容纳其中最大的变体，即 8KB 的字符串。



所以，回答“类型的大小在编译期无法确定，但是我们又需要固定大小的类型时”，以上例子之外的【递归类型】的大小是不确定的，但是我们为了能声明使用它们，就可以使用 Box 智能指针，意味着它是一个指针，指针的是存放在栈上的，栈上的大小是确定的。



### 特征对象和 Box 智能指针

​	`特征对象` 通过将 trait 标记为 `dyn` 并使用 `Box` 或引用进行封装来创建。这样的数组在内存中存储的是指向不同类型对象的指针，每个对象的大小可能不同。在编译时无法确定具体类型，只有在运行时才能确定。



![image-20230510202456904](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230510202456904.png)

以上代码将不同类型的 `Button` 和 `Select` 包装成 `Draw` 特征的特征对象，放入一个数组中，`Box<dyn Draw>` 就是特征对象。







### Rc 和 Arc 智能指针

Rust 所有权机制要求一个值只能有一个所有者，在大多数情况下，都没有问题，但是考虑以下情况：

- 在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理
- 在多线程中，多个线程可能会持有同一个数据，但是你受限于 Rust 的安全机制，无法同时获取该数据的可变引用



考虑一个场景，有很多小工具，每个工具都有自己的主人，但是存在多个工具属于同一个主人的情况。以上场景不是很常见，但是一旦遇到，就非常棘手。

* Rust 在所有权机制之外又引入了额外的措施来简化相应的实现------------【通过引用计数的方式】，允许一个数据资源在同一时刻拥有多个所有者。



这种实现机制就是 `Rc` 和 `Arc`，前者适用于单线程，后者适用于多线程。



### Cell 和 RefCell 智能指针





# 模块 mod

> 模块是构成Rust程序或库的函数、类型、常量等的容器

![image-20230511135516451](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230511135516451.png)



如上例子所示，这是我们之前见到过的代码，它没有使用 `mod` 声明。其他地方可以使用 `mod spores;` 使用该模块，它是正确的，这是因为，当Rust看到 `mod spores;`时，它会检查 【spores.rs】 和 【spores/mod.rs】；这里就是符合第一种情况。



但是，当一个模块拥有子模块时，就需要将使用第二种情况，另外声明单独的 `mod.rs` 去显示声明改模块包含那些子模块。

![image-20230511135949548](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230511135949548.png)



![image-20230511140259153](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230511140259153.png)





# 特征 Trait

`Trait` 类似于抽象方法，它定义了一组可以被共享的行为。



### 为struct实现特征

如下所示，handler 定义了连个通用的方法，实现了该 trait 的 【StaticPageHandler、PageNotFoundHandler、WebServiceHandler】这三个结构体也具有该方法，其中【handle】方法没有具体实现，则可以分别自定义实现。

![image-20230512162432424](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512162432424.png)



### 使用 trait 作为参数

特征如果仅仅是用来实现方法，那真的有些大材小用，现在我们来讲下，真正可以让特征大放光彩的地方。

语法：

* &impl

如下例子，你可以使用任何实现了 `Summary` 特征的类型作为该函数的参数，同时在函数体内，还可以调用该特征的方法。

![image-20230512163006281](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512163006281.png)





### trait 约束

上面的例子，其实只是一个 `语法糖方式`，也就是一个简写。真正的写法应该是如下：

![image-20230512163611119](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512163611119.png)

它表示了，约束输入参数的类型为 Summary 类型，只是因为当只有一个条件的时候，没有发挥其真正的功效，就是【约束多个参数是统同一类型】。例如使用语法糖方式的话，输入类型只要是Summary 类型就可以了，可以分别是【Summary for A】、【Summary for B】，但是无法约束它都是【Summary for A】。这个时候应该采用 `特征约束方式`，如下例子所示：

![image-20230512164827898](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512164827898.png)



### 多重约束和 where 约束



![image-20230512165136776](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512165136776.png)

### 使用 trait 作为返回值和特征对象

​	如下例子所示，可以使用 trait 作为返回值，第一个例子是成功的，但是第二个例子这里会报错， 因为 【Rust 要求你必须明确标出所有的类型】，因为它返回了两个不同的类型 `Post` 和 `Weibo`。

![image-20230512170921883](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512170921883.png)

![image-20230512170658842](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512170658842.png)

【问题】为什么，要使用 trait 作为返回值呢？

* 当我们返回对象时，是为了访问对象里的字段。同理，当我们返回 trait 时，就可以访问 trait 里的方法。



【问题】那么，如何可以让它返回不用类型的元素呢？

* 就好像前面说到的数组章节提到的【如何用数组存储不同类型的元素——可以使用之前讲过的 `枚举类型` 或者 `特征对象`】



![image-20230512171748592](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512171748592.png)

上面所示，【SelectBox、Button】都实现了【Draw trait】，当数组的元素是 Draw 的特征对象时【<Box <dyn Draw>>】，【SelectBox、Button】可以作为元素。

当里面有元素没有实现【Draw trait】时，Rust 不会让它编译通过的。如下所示。

![image-20230515095903964](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230515095903964.png)



### 特征对象（重要）

汇总上面的问题，也就是有没有一种定义是让元素动态的去生成，然后又符合同一类型的概念，以保证它能被作为同一返回类型或者数组元素类型等。这是我们可能想到 `泛型`，但是泛型也是要求返回必须都是是同一个类型。于是 Rust 引入了一个概念  `特征对象`。

特征对象的创建方式有两种：

* 通过 `&` 引用
*  `Box<T>` 



【问题】一个挺重要的问题提及的是，为什么使用 `引用或者智能指针` 的方式来创建特征对象呢？而不是想正常对象那样直接创建呢？

* 特征对象可以是任意实现了某个特征的类型，编译器在编译期不知道该类型的大小，不同的类型大小是不同的
* 而 Rust 要求所有创建必须确定大小，所以特征对象需要使用 `引用或者智能指针` 的方式创建，因为存储在栈中的堆指针的大小是能确定的。



如下所示，使用 & 的方式生成特征对象。u8 和 f64 都是 Draw 类型。

![image-20230629183315487](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230629183315487.png)





### 特征对象的动态分发 dyn

上面得知，可以返回不同元素的特征对象是使用关键字 dyn，来声明的。很明显的意思就是让特征对象具有动态。



【静态分发和动态分发】：

* 泛型是在编译期完成处理的：编译器会为每一个泛型参数对应的具体类型生成一份代码，这种方式是静态分发(static dispatch)，因为是在编译期完成的，对于运行期性能完全没有任何影响。
* 动态分发(dynamic dispatch)，在这种情况下，直到运行时，才能确定需要调用什么方法。之前代码中的关键字 `dyn` 正是在强调这一“动态”的特点。





### self 、Self 和特征对象的限制

在 Rust 中，有两个`self 和 Self`，一个指代当前的实例对象，一个指代特征或者方法类型的别名。



注意，不是所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，它的对象才是安全的：

- 方法的返回类型不能是 `Self`
- 方法没有任何泛型参数

如以下方法就不是对象安全的，因为它的其中一个方法，返回了 `Self` 类型



![image-20230515100835717](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230515100835717.png)



# 模式匹配（重要）

> 用于为复杂的类型系统提供一个轻松的解构能力。允许你从复杂的数据结构中提取和匹配特定的部分。它通过将模式与待匹配的值进行比较来实现解构。如果模式和值匹配成功，就可以提取模式中的各个部分并进行相应的操作。



### 模式匹配场景

模式匹配经常用到，它用来匹配类型中的结构和数据，它往往和 `match` 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：

- 字面值
- 解构的数组、枚举、结构体或者元组
- 变量
- 通配符
- 占位符



如：字面值 【let x = 1】就是一个模式匹配，表示对 1 进行模式匹配，并将匹配结果赋值给 x。

再如下图例子，里面除了字面值以外，还有 3 处地方进行了模式匹配，我们往往忽略了第一处的 `解构的枚举` ，它表示对 【req.resource引用值】 进行模式匹配，并将匹配结果赋值给枚举变量【Path(s)】。

![image-20230512174912453](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512174912453.png)



如果不够形象的话，如下图例子所示：

![image-20230512175605030](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512175605030.png)



### 匹配守卫提供的额外条件

> 匹配守卫（*match guard*）是一个位于 `match` 分支模式之后的额外 `if` 条件，它能为分支模式提供更进一步的匹配条件。



![image-20230512181023715](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230512181023715.png)



# 闭包

### 使用闭包作为参数

先看一下下面的例子，在实际编程中很常见，需要根据不通情况调用同一个处理方法，这时候我们往往会将这个通用方法抽离出来给到一个变量进行存储。如下所示：

![image-20230519164033201](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230519164033201.png)



![image-20230519164117612](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230519164117612.png)



但是，存在一个问题就是，将通用方法抽离出来之后，无论后面的分支需不需要调用这个方法，它都会被至少执行一次。那么我们需要一种方式来实现，将 `函数的定义和执行分离`，只有在需要的时候才执行--------`闭包`。

如下所示，前面只是定义了一个闭包函数，只有调用的时候它才会执行。

![image-20230519164715550](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230519164715550.png)



### 闭包和函数

#### 1、类型声明

* Rust 是静态语言，因此所有的变量都具有类型，但是得益于编译器的强大类型推导能力，在很多时候我们并不需要显式地去声明类型
* 但是显然函数并不在此列，必须手动为函数的所有参数和返回值指定类型，原因在于函数往往会作为 API 提供给你的用户，因此你的用户必须在使用时知道传入参数的类型和返回值类型。
* 与函数相反，闭包并不会作为 API 对外提供，因此它可以享受编译器的类型推导能力，无需标注参数和返回值的类型。



![image-20230519165428562](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230519165428562.png)



#### 2、闭包捕获作用域中的值

闭包还拥有一项函数所不具备的特性：捕获作用域中的值。

对于函数来说，如果想获取函数之外的值，需要通过参数移交所有权或者借用。但是闭包却可以做到，如下所示，闭包内使用【x】值是可以的。

![image-20230519173001931](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230519173001931.png)



#### 3、闭包捕获作用域中的值的方式和 Fn trait

其实，闭包闭包捕获作用域中的值的方式和函数获得参数的方式是一样的，只不过闭包不需要显示地声明参数，Rust 编译器会根据使用值的方式决定具体使用哪个 `Fn trait`。

三种获取值的方式：

* 取得所有权：FnOnce
* 可变借用：FnMut
* 不可变借用：Fn



Rust 自动推导使用哪种方式：

* 所有闭包都实现了 FnOnce

  ![image-20230520172607278](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230520172607278.png)

  

* 没有移出所捕获变量的所有权的闭包自动实现了 FnMut

  ![image-20230519175922448](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230519175922448.png)

  ![image-20230520170412720](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230520170412720.png)

  

* 不需要对捕获变量进行改变的闭包自动实现了 Fn

  ![image-20230519180003645](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230519180003645.png)



对比第一个 FnOnce 的例子和第二个 FnMut 例子，很相似，只是返回值从【s】变成了【s.push_str(str)】，那为什么前一个例子实现的是 FnOnce trait，其实它应该是即实现了 FnOnce trait，又实现了 FnMut。为什么它选中最后实现的是 FnOnce trait 呢？可能是因为最终结果吧。



#### 4、闭包捕获作用域中的值的方式和总结

> `Fn` 的前提是实现 `FnMut`，`FnMut` 的前提是实现 `FnOnce`，因此要实现 `Fn` 就要同时实现 `FnMut` 和 `FnOnce`

如下例子，作用域中声明了两个变量【share_data、cors】，然后闭包app中使用这两个变量，最后启动【HttpServer】时实现这个闭包。

结果是，提示HttpServer需要的是实现 Fn 类型的闭包，但是这里实际实现的是 FnOnce 类型。为什么呢？因为闭包里直接返回了【App】，【App】里面有【share_data、cors】这两个变量，也就是将【share_data、cors】的所有权移交了。

第一版：

![image-20230520180725276](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230520180725276.png)



![image-20230520183207663](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230520183207663.png)



第二版：

使用 clone() 进行深拷贝，创建新的变量，也就不会发生所有权的转移。但是【cors】没有实现 clone() 方法。

![image-20230520181537214](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230520181537214.png)

第三版：

由于【cors】没有实现 clone() 方法，所以只能将它声明在闭包里了。

![image-20230520181959662](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230520181959662.png)



#### 5、move 关键字强制获得所有权

在参数列表前使用 move 关键字，可以强制闭包获得它使用环境值的所有权

* 当闭包传递给新线程以移动数据使得其归新线程所有时，此技术最为有用

![image-20230519180553894](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230519180553894.png)



### 闭包和泛型

上面得知了，Rust编译器能对闭包的类型进行自动推导，虽然类型推导很好用，但是它不是泛型，当编译器推导出一种类型后，它就会一直使用该类型。

如下例子，先，在 `s` 中，编译器为 `x` 推导出类型 `String`，但是紧接着 `n` 试图用 `5` 这个整型去调用闭包，跟编译器之前推导的 `String` 类型不符，因此报错。

![image-20230519165710907](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230519165710907.png)



### 使用闭包作为返回值

之前提到了， `基本数据类型、复合数据类型、trait` 可以作为返回值，`闭包` 也可以作为返回值。但是前提也是，【Rust 要求函数的参数和返回类型，必须有固定的内存大小】。

所以，和【使用 trait 作为返回值和特征对象】一样：

* 第一种是可以使用 `impl trait` 作为返回值
* 第二种是使用 `特征对象` 返回多个不同元素但是是同一个类型的作为返回值。



例子如下所示，但是这里有两个个地方需要注意的：

1. 【Fn(i32) -> i32】就是一个trait，这个是 `闭包trait` 的表示方式，它表示该闭包拥有一个 `i32` 类型的参数，同时返回一个 i`32` 类型的值
2. 乍一看好像第二处返回的类型是一样的。其实不然，每一个闭包实例都有独属于自己的类型，即使于两个签名一模一样的闭包，它们的类型也是不同的。

![image-20230519184514413](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230519184514413.png)





# async/await 异步编程

### async，Rust 的并发编程模型

#### 1、async 简介

提到并发模型，主流的语言基本都支持了，只是支持的方式不一样。如 ErLang 的 actor 模型、Java 的 JMM 模型、JS 的事件驱动模型、Go 的协程模型等。

Rust 提供了 async/await 模型。它是同时提供多线程编程和 async 编程。

- 前者通过标准库实现，当你无需那么高的并发时，例如需要并行计算时，可以选择它，优点是线程内的代码执行效率更高、实现更直观更简单。
- 后者通过语言特性 + 标准库 + 三方库的方式实现，在你需要高并发、异步 `I/O` 时，选择它就对了。



#### 2、同步、多线程、异步的区别

![image-20230901172411047](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230901172411047.png)



多线程例子，如下图所示：

使用的是标准库实现。

![image-20230901175128719](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230901175128719.png)



异步例子，如下图所示。

rust 使用语言特性 + 标准库 + 三方库结合实现。

![image-20230901175453487](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230901175453487.png)



事实上， async 底层也是基于线程实现，但是它基于线程封装了一个【运行时（Runtime）】，可以将多个任务映射到少量线程上，然后将线程切换变成了任务切换，后者仅仅是内存中的访问，因此要高效的多。



【注意】Rust 没有内置异步调用所必需的运行时，但是无需担心，Rust 社区生态中已经提供了非常优异的运行时实现——Tokio。



【问题】为什么运行时中高效的多？

* 参考【tokio 核心之 task】



### Future trait（重要）

> 异步函数是异步编程的核心，Future 是异步函数的返回值和被执行的关键。



各个组件之间的执行过程，如下所示：

![image-20230919145002692](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230919145002692.png)



#### 1、async 关键字

对比前面异步例子中的async方法，方法前加上 async 和 使用 async{} 是等价的，最后的返回值都是 Future。

![image-20230901175820259](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230901175820259.png)



#### 2、Future

以下是一个简易的 Future trait，如下所示。

~~~rust
trait SimpleFuture {
    type Output;
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),
    Pending,
}
~~~



poll 方法会被运行时反复调用，运行时里的执行器调用 poll 方法会得到两种结果，也就是 Poll 枚举中的定义的。

* 如果得到的是 Ready，那么执行器 Exector 就会解析 Future 得到结果。
* 如果得到的是 Pending，那么当前任务会被注册到 Waker 组件。



#### 3、Waker 组件

【问题】为什么需要注册到 Waker 组件，而不是执行器 Exector 定期地的轮询呢？

* 定期轮训的话，执行器会管理所有的 Future，所以需要轮训所以的 Future，这种方式效率低。
* 通过引入中间件 Waker，来处理监听任务，它监听 Future 的值可用时就会主动通知执行器。执行器收到 Waker 的通知后，才进行再次调用 poll 方法。返回 Future 结果。

【事件通知 -> 执行】的方式要远比【定期轮训】对所有进行一次全遍历来的高效。



以下是源码 Future trait，如下所示。

~~~ rust
trait Future {
    type Output;
    fn poll(
        // 首先值得注意的地方是，`self`的类型从`&mut self`变成了`Pin<&mut Self>`:
        self: Pin<&mut Self>,
        // 其次将`wake: fn()` 修改为 `cx: &mut Context<'_>`:
        cx: &mut Context<'_>,
    ) -> Poll<Self::Output>;
}
~~~



对比之前简易的 Future，主要是为了突出的是，poll 方法的入参变成了 Context，

* 即 wake 是由上下文对象管理的，上下文管理着所有任务和任务对应的 wake 等信息
* [Rust 语言圣经](https://course.rs/advance/async/future-excuting.html)  中提到的原因是让执行器 Exector 知道哪个 Future 调用了 wake 方法。
* 是因为，前者是一个无参函数，执行完了就完了，Future 没有给到执行器任何通知。所以，需要使用通过 Context 给到执行器额外的信息。





#### 4、Reactor 组件

【问题】Waker 怎么知道 Future 的值可用了呢？

1. 所有的任务在系统内核处理完成后，系统通过系统中断的方式响应程序。
2. 引入 Reactor 响应器，Reactor 能识别系统的响应为一个事件。
3. Reactor 在队列中唤醒事件对应的任务 task。
4. task 通知它的 Waker 组件。

task --> Future --> Waker。每个 task 对应一个 Future，每个 Future 对应一个 Waker。



![image-20230902232031600](https://note-1305755407.cos.ap-nanjing.myqcloud.com/note/image-20230902232031600.png)



#### 5、Exector 组件

前面 Waker 组件的时候提到了，执行器不会一直对 Future 进行 poll，当 Waker 组件通知的时候才会再次 poll。

Exector 负责管理异步操作的执行顺序和状态转换。Future 是懒惰的，直到被执行器 poll 或 .await 后才会开始运行。【注意】

* 其中后者是最常用的运行 Future 的方法。
* 但是当这个异步操作是最外层是，只能通过执行器 poll 来运行，如 main 函数。









### async 关键字（重要）

前面主要是介绍 rust 异步编程的原理，这里主要是就介绍如何进行 rust 异步编程。

有两种方式可以使用 async：

* async fn 用于声明函数
* async { ... } 用于声明语句块



#### 1、async 生命周期

异步函数如果拥有引用类型的参数，那它返回的 Future 的生命周期就会被这些参数的生命周期所限制，即参数要比 Future 活得久。

如下所示，参数 x 需要比 Future 活的久才行。

~~~rust
async fn foo(x: &u8) -> u8 { *x }

// 上面的函数跟下面的函数是等价的:
fn foo_expanded<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {
    async move { *x }
}
~~~



在一般情况下，在函数调用后就立即 .await 不会存在任何问题，例如上面的例子，foo(&x).await。但是，若 Future 被先存起来或发送到另一个任务或者线程，就可能存在问题了，如下所示。

~~~rust
use std::future::Future;
fn bad() -> impl Future<Output = u8> {
    let x = 5;
    borrow_x(&x) // ERROR: `x` does not live long enough
}

async fn borrow_x(x: &u8) -> u8 { *x }
~~~



x 的生命周期只到 bad 函数结束，显然 borrow_x 的 Future 存活更久，这会导致编译不通过。解决的方法就是使用 static 生命周期，如下所示。

通过将参数和对 async fn 的调用放在同一个 async 语句块来实现。

~~~rust
use std::future::Future;
 
async fn borrow_x(x: &u8) -> u8 { *x }

fn good() -> impl Future<Output = u8> {
    async {
        let x = 5;
        borrow_x(&x).await
    }
}
~~~



【问题】为什么使用 async 语句块就可以拥有 static 的生命周期了呢？

* 将参数和 async 函数作用在另外一个 async 函数，那么它们的生命周期都是一样的直到这个新的 async 函数结束。



#### 2、async move

除了以上重新声明一个 asycn 函数以外，可以类似闭包的做法，使用 move 关键字将变量的所有权移交到 async 函数内，如下所示。

~~~rust
fn move_block() -> impl Future<Output = ()> {
    let my_string = "foo".to_string();
    async move {
        // ...
        println!("{my_string}");
    }
}
~~~

以上，my_string 已经将所有权移交到了 async 函数。存在一个相同的缺点就是，my_string 不能被其它的 异步函数使用了。



#### 3、当 .wait 遇到 Exector（注意）

当异步函数被 Exector 执行时，Future 可能会在线程间被移动，因此 async 语句块中的变量必须要能在线程间传递。而使用以下的类型，都有线程安全的问题：

1. Rc、RefCell。
2. 实现 Send 的所有权类型
3. 实现 Sync 的引用类型



【注意】在使用 .await 调用期间，这些不安全的类型可能会被使用。这是因为异步任务的执行通常是在单线程内部进行的。但是，一旦异步任务被 .await 挂起并切换到其他任务，这些类型的不安全性问题就会浮现出来。



类似的原因，在异步编程的过程中，普通的锁也是不安全。例如，此时使用 Mutex 是不安全的，要使用 futures 包下的锁。后续继续了解【futures 包】。

例子如下：

~~~bash
当使用标准库的 Mutex 时：
1. 当一个任务A获取到锁后，如果该任务将线程的控制权还给执行器（异步任务调度器），此时A还没有释放锁，因他只是想”休息“一会儿，但是当A”休息”。
2. 执行器就会把执行的线程，再调度另一个任务。
3. 这第二个任务B也尝试获取锁，那么当前线程就可能会被直接挂起（卡住），最终可能导致死锁。
~~~



### Rc、RefCell、Send、Sync 和线程安全

参考【Rc 和 Arc 智能指针】，Rc 和 RefCell 是用于单线程的，多线程使用 Arc。



#### 1、Rc 和 Arc 对比

~~~rust
// Rc源码片段
impl<T: ?Sized> !marker::Send for Rc<T> {}
impl<T: ?Sized> !marker::Sync for Rc<T> {}

// Arc源码片段
unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}
unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}
~~~

可以看到 Rc 移除了 Send trait 相关，而 Arc 则是实现了 Sync+Send trait 相关，所以，Ac 的线程安全和其有关。



#### 2、Send 和 Sync

它们是 Rust 安全并发的重中之重，来看看它们的作用：

- 实现 Send 的类型，可以在线程间安全的传递其所有权。
- 实现 Sync 的类型，可以在线程间安全的共享(通过引用)。



>这里还有一个潜在的依赖：一个类型要在线程间安全的共享的前提是，指向它的引用必须能在线程间传递。因为如果引用都不能被传递，我们就无法在多个线程间使用引用去访问同一个数据了。



#### 3、RwLock、Mutex 和 Send、Sync

RwLock 和 Mutex 源码如下：

~~~rust
// RwLock
unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}

// Mutex
unsafe impl<T: ?Sized + Send> Sync for Mutex<T> {}
~~~

我们知道 RwLock 读写锁是可以并发读的，意味着 T 肯定需要在线程间安全共享，果不其然，看到了 Sync trait。

但是 Mutex 互斥锁是同时只能一个线程进行访问 T，所以它没有 Sync trait。



#### 4、实现 send 和 sync 的类型

下面看看实现了 send+sync trait 的类型都有哪些。

在 Rust 中，几乎所有类型都默认实现了，因为几乎所有的类型都是是 derive 派生的，而 send+sync 都是可以自动派生的。

* 当一个复合类型，它内部的所有成员都是实现了 send+sync，那么这个结构体就自动实现了 send+sync。

~~~rust
#[derive(Debug)]
pub struct
~~~



当然，自定义结构体就不一定实现了 send+sync，因为只要有一个成员不是，那就不会自动实现。而且通常不要手动实现 send+sync trait，实现者需要使用 unsafe 关键字小心维护。



#### 5、为裸指针实现 Send

虽然不建议手动实现，但是了解一下怎么实现可以让自定义结构体可以在线程间安全的使用。

下面使用没有实现 send+trait 的裸指针，实现一下：

~~~rust
// 直接在多线程中使用裸指针
use std::thread;
fn main() {
    let p = 5 as *mut u8;
    let t = thread::spawn(move || {
        println!("{:?}",p);	// 提示错误，*mut u8` cannot be sent between threads safely
    });

    t.join().unwrap();
}

// 实现send后
use std::thread;

#[derive(Debug)]
struct MyBox(*mut u8);
unsafe impl Send for MyBox {}

fn main() {
    let p = MyBox(5 as *mut u8);
    let t = thread::spawn(move || {
        println!("{:?}",p);
    });

    t.join().unwrap();
}
~~~



裸指针：*mut u8，需要转换为结构体，然后结构体实现 send trait，既可以达到目的。

* 使用 newType 类型，通过元组的方式将已知的类型包裹起来，实现了一个重命名的作用。
* 因为元组是不需要关注名称，只需要类型。



~~~rust
// 元组结构体
struct Color(i32, i32, i32);

// newType，只有一个类型的元组结构体
struct Color(i32)
~~~





### Stream trait

Stream trait 类似于 Future trait，但是前者在完成前可以生成多个值。

~~~rust
trait Stream {
    // Stream生成的值的类型
    type Item;

    // 尝试去解析Stream中的下一个值,
    // 若无数据，返回`Poll::Pending`, 若有数据，返回 `Poll::Ready(Some(x))`, `Stream`完成则返回 `Poll::Ready(None)`
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<Option<Self::Item>>;
}
~~~



### futures 包

futures 包中提供了很多并发下实用的工具。

* join!，它允许我们同时等待多个不同 Future 完成。
* try_join!，由于 join! 必须等待它管理的所有完成后才能完成，try_join! 可以某一个报错后就立即停止所有 Future 的执行。
* select!，多个中选择任意一个完成后就停止。



# Tokio 框架

前面【async，Rust 的并发编程模型】介绍时提到了，Rust 没有内置异步调用所必需的运行时，以下就是介绍 tokio 提供的 runtime。



### 一、tokio 核心之 runtime

tokio 提供了两种工作模式的 runtime：

- 1.单一线程的 runtime，current thread runtime
- 2.多线程(线程池)的runtime，multi thread runtime



首先分析一下代码，代码如下：

1. 它创建了一个异步任务，该任务生成整数值（1 到 10），并将它们发送到一个通道，同时主任务异步等待并接收来自通道的数据。
2. 它有两个任务，主任务和 tokio::spawn() 方式创建的异步任务。
3. 它至少两个线程在执行，一个线程执行主任务，一个线程执行异步任务。它使用 Runtime::new() 创建的运行时环境，默认是多线程，tokio::spawn 的异步任务是可以跨线程的，所以异步任务可能更多线程在执行

~~~rust
use tokio::{ self, runtime::Runtime, sync };

fn main() {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        let (tx, mut rx) = sync::mpsc::channel::<i32>(10);

        tokio::spawn(async move {
            for i in 1..=10 {
                if tx.send(i).await.is_err() {
                    println!("receiver closed");
                    return;
                }
            }
        });

        while let Some(i) = rx.recv().await {
            println!("received: {}", i);
        }
    });
}
~~~





#### 1、创建 tokio runtime

要使用 tokio，需要先创建它提供的异步运行时环境(Runtime)，然后在这个 Runtime 中执行异步任务。

~~~rust
// 创建单一线程的runtime
let rt = tokio::runtime::Builder::new_current_thread().build().unwrap();
~~~



~~~rust
// 创建多线程的runtime，默认创建的是多线程，工作线程数是CPU核数。
use tokio;

fn main(){
  let rt = tokio::runtime::Runtime::new().unwrap();
  std::thread::sleep(std::time::Duration::from_secs(10));
}
~~~



#### 2、async main

可以看到，一般我们希望在 main 函数就使用 tokio。于是对于 main 函数，tokio 提供了简化的异步运行时创建方式。使用注解【\#[tokio::main]】。

~~~rust
#[tokio::main]
async fn main() {}

// 等价于

fn main(){
  tokio::runtime::Builder::new_multi_thread()
        .worker_threads(N)  
        .enable_all()
        .build()
        .unwrap()
        .block_on(async { ... });
}
~~~



#### 3、多个 runtime 共存

略....................



#### 4、进入 runtime，执行异步任务

提供了 Runtime 后，就可以在 Runtime 中执行异步任务 Future。

* block_on()，会阻塞主线程
* enter()，不会阻塞主线程



使用 Runtime 的 block_on，进入 Runtime，然后执行异步任务 sleep()。 例子如下所示。

~~~rust
use tokio::runtime::Runtime;
use chrono::Local;

fn main() {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        println!("before sleep: {}", Local::now().format("%F %T.%3f"));
        tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;  // tokio的sleep是异步的，impl Future for Sleep
        println!("after sleep: {}", Local::now().format("%F %T.%3f"));
    });
}

##结果如下：
##before sleep: 2023-09-04 13:39:43.323
##after sleep: 2023-09-04 13:39:45.341
~~~



#### 5、理解 runtime 和异步调度

Runtime trait，如下所示。

~~~rust
pub struct Runtime {
    /// Task scheduler
    scheduler: Scheduler,

    /// Handle to runtime, also contains driver handles
    handle: Handle,

    /// Blocking pool handle, used to signal shutdown
    blocking_pool: BlockingPool,
}
~~~

Runtime 还提供了任务调度器 Scheduler、Handle、阻塞池 BlockingPool。

1. 当一个异步任务需要运行，任务要就绪队列然后等待被调度。当一个异步任务需要阻塞时，它被放进阻塞队列。
2. 阻塞队列中的每一个被阻塞的任务，都需要等待 Reactor 收到对应的事件通知(比如IO完成的通知、睡眠完成的通知等)来唤醒它。当该任务被唤醒后，它将被放入就绪队列，等待调度器的调度。
3. 就绪队列中的每一个任务都是可运行的任务，可随时被调度器调度选中。调度时会选择哪一个任务，是调度器根据【调度算法】去决定的。某个任务被调度选中后，调度器将分配一个线程去执行该任务。





#### 6、tokio 异步调度和系统进程调度

异步运行时和操作系统的进程调度方式是类似的，只不过现代操作系统的进程调度逻辑要比异步运行时的调度逻辑复杂的多。

大方向上来说，有两种调度策略：

* 抢占式调度
* 协作式调度，tokio 的调度策略是协作式调度策略。

对于面向大众使用的操作系统(如 Linux )通常采用【抢占式调度策略】来保证系统安全，避免恶意程序霸占CPU。而对于语言层面来说，通常采用【协作式调度策略】，这样既有底层 OS 的抢占式保底，又有协作式的高效。



#### 7、tokio 的两种类型的线程：worker thread 和 blocking thread

tokio 提供了两种功能的线程：

- worker thread，用于异步任务的工作线程，默认存在。
- blocking thread，用于同步任务的阻塞线程，需要使用 spawn_blocking() 创建。



【问题】为什么要区分为两种线程类型呢？

* 异步任务中还会包含其它任务，如果这个包含的任务耗时非常的长或者直接阻塞主线程， 这会破坏异步调度。调度器获得当前线程的所有权去调度其它任务了。
* 所以，blocking thread，用于那些长时间计算的或阻塞整个线程的任务。



如下例子所示。

前者是使得整个线程进入睡眠，由于这类阻塞操作不在 tokio 系统内，tokio 无法识别这类线程阻塞的操作，tokio 只能等待该线程阻塞操作的结束，才能重新获得那个线程的管理权。

后者是阻塞当前任务，调度器能够识别。此时会直接放弃 CPU，将线程交还给调度器，使该线程能够再次被调度器分配到其它异步任务。

~~~rust
rt.block_on(async{
  // 在runtime中，让整个线程进入睡眠
  std::thread::sleep(std::time::Duration::from_secs(10));
});


rt.block_on(async{
  // 在runtime中，当前任务进入睡眠
  tokio::time::sleep()(std::time::Duration::from_secs(10));
});
~~~



【问题】使用 blocking thread 的好处

blocking thread 有时候是非常友好的，它像独立线程一样，但又和 runtime 绑定，它不受 tokio 的调度系统调度，tokio 不会把其它任务放进该线程，也不会把该线程内的任务转移到其它线程。换言之，它有机会完完整整地发挥单个线程的全部能力，而不像 worker 线程一样，可能会被调度器打断。



使用 blocking thread 处理长时间计算任务例子，如下所示。

~~~rust
use std::thread;
use chrono::Local;
use tokio::{self, runtime::Runtime, time};

fn now() -> String {
    Local::now().format("%F %T").to_string()
}

fn main() {
    let rt1 = Runtime::new().unwrap();
    // 创建一个blocking thread，可立即执行(由操作系统调度系统决定何时执行)
    // 注意，不阻塞当前线程
    let task = rt1.spawn_blocking(|| {
      println!("in task: {}", now());
      // 注意，是线程的睡眠，不是tokio的睡眠，因此会阻塞整个线程
      thread::sleep(std::time::Duration::from_secs(10))
    });

    // 小睡1毫秒，让上面的blocking thread先运行起来
    std::thread::sleep(std::time::Duration::from_millis(1));
    println!("not blocking: {}", now());

    // 可在runtime内等待blocking_thread的完成
    rt1.block_on(async {
      task.await.unwrap();
      println!("after blocking task: {}", now());
    });
}
~~~



### 二、tokio 核心之 task

前面介绍【tokio 的两种类型的线程：worker thread 和 blocking thread】，可以知道。tokio严格区分异步任务和同步任务，但是只有异步任务才算是 tokio task。



#### 1、tokio task 的常用函数

* spawn()，在当前的 runtime 中生成一个异步任务。
* spawn_blocking()，生成一个 blocking thread 来执行指定的任务。
* spawn_local()，【重要】
* block_in_place()，将异步任务转移到其它 worker thread，在当前 worker thread 继续执行任务耗时非常的长的任务。
* yield_now()，让当前任务立即放弃 CPU，将worker thread交还给调度器。
* unconstrained()，创建一个不受限制不受调度器管理的异步任务。



【问题】unconstrained() 的用处是什么？

除了 spawn_blocking() 以外，其它都是使用的 worker thread，如果真的遇到了耗时的任务：

* block_in_place() 的处理方式是，将其它异步任务调度到其它 worker thread。
* unconstrained() 的处理方式是，不给调度器管理？就是让它阻塞？.............................. 暂时不理解它的用处。





#### 2、LocalSet 和 spawn_local()

在多线程 runtime 时，意味着异步任务可能会不受预料地被跨线程执行。

tokio 提供了让某些任务固定在某一个线程中运行的功能，叫做 LocalSet。这些异步任务被放在一个独立的本地任务队列中，它们不会跨线程执行。



使用方式，如下所示。

1. 创建 LocalSet。
2. 使用 LocalSet.spawn_local()，添加异步任务。
3. 使用 LocalSet::run_until()、LocalSet::block_on()，执行异步任务。



【注意】LocalSet 中可能是存在多个任务的，当某一任务执行完后就会直接返回。需要注意的是，此时其它任务也还在正常地被调度执行，只有当再次进入 LocalSet 并且执行能被调度的任务，这些其它任务才会唤醒。

简而言之，就是，其它的任务睡眠了，需要有人激活才会唤醒。



~~~rust
// 无法唤醒，因为没有 Future
local_tasks.block_on(&rt, async {
  println!("re-enter localset context, and exit context");
  println!("task2 will not be scheduled");
})

// 可以唤醒，看到.await了吗
rt.block_on(async {
        local_tasks
            .run_until(async {
                println!("local task2");
                time::sleep(time::Duration::from_secs(3)).await;
                println!("local task2 done: {}", now());
            })
            .await;
    });
~~~



【问题】LocalSet 使用时，那异步任务都不会跨线程执行了，是不是不用考虑线程安全的问题了？

* 呃呃呃，异步编程当然需要考虑线程安全问题。
* 多线程编程是多个线程操作共享数据导致线程安全问题。异步编程是一个线程多个任务操作共享数据导致的线程安全问题。





### 三、tokio timer

* Duration
* Instant
* Sleep
* Interval
* Timeout



### 四、tokio 任务间通信

参考【java笔记-消息传递和 Actor 模型】



【共享数据】和【消息传递】是两种常用得线程通信方式。rust tokio 采用的是【消息传递】的方式。



#### 1、通信通道

消息传递通常使用 channel 来进行通信。tokio提供几种不同功能的通道：

* oneshot
* mpsc，多对一发送，即该通道可以同时有多个发送者向该通道发数据，但只有一个接收者接收数据【最常用】
* broadcast
* watch



#### 2、通信通道-mpsc 通道

mpsc 通道分为：

* 有界通道
* 无界通道



mpsc 有界通道例子，如下所示。

* 前者生成了一个异步任务，该异步任务向通道中发送 10 个数据。
* 后者生成 10 个异步任务分别发送数据。

【注意】tx 是 channel 的 Sender，rx 是 channel 的 Receiver。

~~~rust
use tokio::{ self, runtime::Runtime, sync };

fn main() {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        let (tx, mut rx) = sync::mpsc::channel::<i32>(10);

        tokio::spawn(async move {
            for i in 1..=10 {
                if tx.send(i).await.is_err() {
                    println!("receiver closed");
                    return;
                }
            }
        });

        while let Some(i) = rx.recv().await {
            println!("received: {}", i);
        }
    });
}

// 输出：
received: 1 
received: 2 
received: 3 
received: 4 
received: 5 
received: 6 
received: 7 
received: 8 
received: 9 
received: 10
~~~



~~~rust
use tokio::{ self, runtime::Runtime, sync };

fn main() {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        let (tx, mut rx) = sync::mpsc::channel::<i32>(10);

        for i in 1..=10 {
            let tx = tx.clone();
            tokio::spawn(async move {
                if tx.send(i).await.is_err() {
                    println!("receiver closed");
                }
            });
        }
        drop(tx);

        while let Some(i) = rx.recv().await {
            println!("received: {}", i);
        }
        
    });	// 如果不手动drop(tx)，tx到这里才会被自动drop
}

// 输出：
received: 2 
received: 1 
received: 3 
received: 5 
received: 6 
received: 7 
received: 8 
received: 9 
received: 10
received: 4 
~~~



【解释】可以看到，两个例子有两个不同之处。前者 tx 所有权移交了闭包函数，当函数结束时 tx 就会被自动 drop。后者每次销毁的是克隆的 tx，但是原始的 tx 需要等到整个函数函数结束。









#### 3、状态同步和线程安全

消息传递的方式，通常还会提到【状态同步】。如果任务间需要有序性时，就需要检查每个任务的状态了。显而易见的是，无序才会有更好的性能，但是无法避免需要有序的场景。

* Actor 模型也采用了【消息传递】的方式，它对于状态同步的解决方案是，通过【单线程 +  Actor 自己维护状态】的方式。
* tokio 的状态同步使用过锁来实现的。



【问题】这时候，会疑问为什么使用了消息传递的方式了，消灭数据竞争了，还会需要锁？

* 这里消息传递的方式保证的是消息的安全性
* 这里锁保证的是【状态】，任务的状态。任务的状态通常是共享数据。



【任务间通信和线程安全】

* 多线程编程具有线程安全问题。异步编程中”多任务编程“也同样具有线程安全问题。
* 多个任务同时操作共享数据，会有线程安全问题。



#### 4、状态同步-Mutex互斥锁

Mutex 例子，如下所示。

~~~rust
use std::sync::Arc;
use tokio::{self, sync, runtime::Runtime, time::{self, Duration}};

fn main() {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        let mutex = Arc::new(sync::Mutex::new(0));

        for i in 0..10 {
            let lock = Arc::clone(&mutex);
            tokio::spawn(async move {
                let mut data = lock.lock().await;
                *data += 1;
                println!("task: {}, data: {}", i, data);
            });
        }

        time::sleep(Duration::from_secs(1)).await;
        println!("finish");
    });
}
~~~



可以看到，任务的调度顺序是随机的，但是数据加 1 的操作是依次完成的。因为使用了互斥锁，互斥锁是线程级别的，每次只有一个线程可以获取共享变量 。

~~~bash
task: 1, data: 1
task: 0, data: 2 
task: 2, data: 3 
task: 3, data: 4 
task: 4, data: 5 
task: 5, data: 6 
task: 6, data: 7 
task: 7, data: 8 
task: 8, data: 9 
task: 9, data: 10
finish
~~~



【注意】tokio::sync::Mutex 其内部使用了标准库的互斥锁，即 std::sync::Mutex，而标准库的互斥锁是针对线程的，因此，使用 tokio 的互斥锁时也会锁住整个线程。官方文档中建议，如非必须，应使用标准库的 Mutex。





#### 5、状态同步-RwLock 读写锁

读写锁允许多个读锁共存，但写锁独占

例子如下所示。读锁 r1、r2 共存，然后在代码块后被自动 drop，接着写锁 w 申请锁并且获得了锁。

~~~rust
use tokio::sync::RwLock;

#[tokio::main]
async fn main() {
    let lock = RwLock::new(5);

    // 多个读锁共存
    {
        // read()返回RwLockReadGuard
        let r1 = lock.read().await;
        let r2 = lock.read().await;
        assert_eq!(*r1, 5);  // 对Guard解引用，即可得到其内部的值
        assert_eq!(*r2, 5);
    } // 读锁(r1, r2)在此释放

    // 只允许一个写锁存在
    {
        // write()返回RwLockWriteGuard
        let mut w = lock.write().await;
        *w += 1;
        assert_eq!(*w, 6);
    } // 写锁(w)被释放
}
~~~



tokio RwLock 实现的是写锁优先，即如果申请的是读锁，但此时有写锁(包括写锁申请)的存在，那么将等待所有的写锁释放。所有以下代码会发生死锁。

~~~rust
use std::sync::Arc;
use tokio::{self, runtime::Runtime, sync::RwLock, time::{self, Duration}};

fn main() {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        let lock = Arc::new(RwLock::new(0));

        let lock1 = lock.clone();
        tokio::spawn(async move {
            let n = lock1.read().await;

            time::sleep(Duration::from_secs(2)).await;
            let nn = lock1.read().await;
        });

        time::sleep(Duration::from_secs(1)).await;
        let mut wn = lock.write().await;
        *wn = 2;
    });
}
~~~



发生死锁的流程，如下所示：

1. 申请第一把读锁时，因为此时无锁，所以读锁 n 申请成功。
2. 1 秒后申请写锁时，由于此时读锁 n 尚未释放，因此写锁申请失败，将等待。
3. 再 1 秒之后，继续在子任务中申请读锁，但是此时有写锁申请存在，因此第二次申请读锁将等待。
4. 于是读锁写锁互相等待，读锁 n 拥有的锁也一直得不到释放，死锁出现了。



解决办法，就是使用读写锁时，每次都手动 drop。





# Tokio 框架之异步 IO

任何一个异步框架的核心目标都是异步 IO，更高效率的 IO 编程也是多数时候我们使用异步框架的初衷。

tokio 的异步 IO 组件封装了 std::io 中的几乎所有东西的异步版本。



### 一、文件 IO

简单例子如下所示。

~~~rust
let file = tokio::fs::File::open("/tmp/a.log").await.unwrap();

// 将file转换为BufReader
let mut buf_reader = tokio::io::BufReader::new(file).lines();

// 每次读取一行
while let Some(line) = buf_reader.next_line().await.unwrap() {
    // 注意lines()中的行是不带结尾换行符的，因此使用println!()而不是print!()
    println!("{}", line);
}
~~~



【问题】为什么不直接读取 file，而是要先转换为 buf 呢？

* 如果你使 File 直接读取文件内容，你会一次性读取一个字节（或多个字节），然后需要自己处理这些字节来构建字符串。这可能涉及到字符编码、字符串分隔符、字符拼接等操作，而这些操作在处理文件内容时可能会引入错误或使代码变得更复杂。
* 这些，buf 具有更高级的字符串操作。





### 二、网络 IO【重要】

#### 1、AsyncRead 和 AsyncWrite

它们对应的是标准库中 Read 和 Write 这两个 Trait 的异步版本。tokio::fs::File、tokio::net::TcpStream 等都实现了，所以具有异步能力。

当需要进行异步读、写的时候，不会像同步的读写一样阻塞线程，而是会等待可读、可写事件的发生，同时切换到调度器使其能在等待事件发生的过程中调度其它异步任务来执行。



#### 2、AsyncReadExt 和 AsyncWriteExt

AsyncRead 和 AsyncWrite 只是提供了最基本的异步读写能力，它们并没有提供方便的读写方式。通过开启 tokio 的 io-util 特性后，就会自动拥有 AsyncReadExt 和 AsyncWriteExt 中定义的一些方便的读写方法。

例如：

* read()
* read_buf()
* write()
* write_all()
* flush()



#### 3、AsyncBufRead 和带缓冲的读写

文件 IO 操作，也就是从硬盘读取数据或写入数据。每次文件的 IO 都会立即向操作系统请求发起一次读、写系统调用。

tokio 中对应的缓冲区实现就是 AsyncBufRead、BufReader、BufWriter。



【注意】只有 AsyncBufRead，没有 AsyncBufWrite Triat。



【问题】为什么没有 AsyncBufWrite Trait？





#### 4、分离出 Reader 和 Writer

tokio::io::split() 方法可将可读也可写的 Stream 分离为 Reader 和 Writer。

~~~rust
// 分离 TcpStream
async fn process_client(client_stream: TcpStream) {
    let (client_reader, client_writer) = client_stream.into_split();
}


// 分离 DuplexStream
async fn read_duplex(r: DuplexStream) {
    let (mut reader, writer) = tokio::io::split(r);
}
~~~



#### 5、Stream 和 Sink

前面的异步 IO 的时候，相关的读写操作都非常底层，要么直接操作字节，要么直接操作更高一层的 Buffer 的操作字符。Stream 和 Sink 可以以【Frame】为读写单位进行读写操作。

* Stream Trait 用于读操作
* Sink Trait 用于写操作。



#### 6、StreamExt 和 SinkExt

和 Read 和 Write一样，StreamExt 和 SinkExt 都只是提供了非常原始的方法，更多时候我们会使用 StreamExt 和 SinkExt 中提供的扩展方法来简化读写操作。

tokio_stream 提供了 StreamExt，futures 和 futures_util 中提供了 StreamExt 和 SinkExt。

* send()
* feed()
* flush()
* sendAll()



#### 7、codec 和 Framed

* codec::Decoder 可以将 AsyncRead 转换为 FramedRead
* codec:: Encoder 可以将 AsyncWrite  转换为 FramedWrite
* codec::Decoder + codec:: Encoder 可以将转换为 Frame

~~~rust
// T是实现了AsyncRead的类型，例如TcpStream、File等  
// D是实现了Decoder的类型，例如LinesCodec、BytesCodec等
let framed_reader = FramedRead::new(T, D);

// T是实现了AsyncWrite的类型，例如TcpStream、File等  
// E是实现了Encoder的类型，例如LinesCodec、BytesCodec等
let framed_writer = FramedWrite::new(T, E);

// T是实现了AsyncRead + AsyncWrite的类型，例如TcpStream、File等  
// U是实现了Encoder + Decoder的类型，例如LinesCodec、BytesCodec等
let framed = Framed::new(T, U);
~~~



除了使用 Frame 中的方法生成 Frame，还可以使用 Decoder 中的 framed() 方法生成。

~~~rust
let framed = LinesCodec::new().framed(T);
~~~



常用的，已经同时实现了 Decoder、Encoder 的类型，如下所示。

- LinesCodec：以行为单位的帧
- AnyDelimiterCodec：以指定分隔符为单位的帧
- BytesCodec：以字节为单位的帧



【注意】Framed 还可通过 split() 方法分离出独立的 Stream 和 Sink分别进行读写。

使用 LinesCodec 将 Stream 转换为 Framed，并且使用 split() 分离 Framed，如下所示。

~~~rust
// 1、将TcpStream转换为Framed
let framed = Framed::new(client_stream, LinesCodec::new());
// 2、将Framed分离，可得到独立的读写端
let (frame_writer, frame_reader) = framed.split::<String>();
~~~



### 三、网络 IO-例子1

~~~rust
use futures_util::stream::{SplitSink, SplitStream};
use futures_util::{SinkExt, StreamExt};
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::mpsc;
use tokio_util::codec::{Framed, LinesCodec};

type LineFramedStream = SplitStream<Framed<TcpStream, LinesCodec>>;
type LineFramedSink = SplitSink<Framed<TcpStream, LinesCodec>, String>;

#[tokio::main]
async fn main() {
    let server = TcpListener::bind("127.0.0.1:8888").await.unwrap();
    while let Ok((client_stream, _client_addr)) = server.accept().await {
        // 每接入一个客户端的连接请求，都分配一个子任务，
        // 如果客户端的并发数量不大，可为每个客户端都分配一个thread
        tokio::spawn(async move {
            process_client(client_stream).await;
        });
    }
}

async fn process_client(client_stream: TcpStream) {
  	// 将TcpStream转换为Framed
    let framed = Framed::new(client_stream, LinesCodec::new());
    
    // 将Framed分离，可得到独立的读写端
    let (frame_writer, frame_reader) = framed.split::<String>();
    
    // 当Reader从客户端读取到数据后，发送到通道中，
    // 另一个异步任务读取该通道，从通道中读取到数据后，将内容按行写给客户端
    let (msg_tx, msg_rx) = mpsc::channel::<String>(100);

    // 负责读客户端的异步子任务
    let mut read_task = tokio::spawn(async move {
        read_from_client(frame_reader, msg_tx).await;
    });

    // 负责向客户端写行数据的异步子任务
    let mut write_task = tokio::spawn(async move {
        write_to_client(frame_writer, msg_rx).await;
    });

    // 无论是读任务还是写任务的终止，另一个任务都将没有继续存在的意义，因此都将另一个任务也终止
    if tokio::try_join!(&mut read_task, &mut write_task).is_err() {
        eprintln!("read_task/write_task terminated");
        read_task.abort();
        write_task.abort();
    };
}





async fn read_from_client(mut reader: LineFramedStream, msg_tx: mpsc::Sender<String>) {
    loop {
        match reader.next().await {
            None => {
                println!("client closed");
                break;
            }
            Some(Err(e)) => {
                eprintln!("read from client error: {}", e);
                break;
            }
            Some(Ok(str)) => {
                println!("read from client. content: {}", str);
                // 将内容发送给writer，让writer响应给客户端，
                // 如果无法发送给writer，继续从客户端读取内容将没有意义，因此break退出
                if msg_tx.send(str).await.is_err() {
                    eprintln!("receiver closed");
                }
            }
        }
    }
}

async fn write_to_client(mut writer: LineFramedSink, mut msg_rx: mpsc::Receiver<String>) {
    while let Some(str) = msg_rx.recv().await {
        if writer.send(str).await.is_err() {
            eprintln!("write to client failed");
            break;
        }
    }
}
~~~



流程如下：

1. 为每一个客户端请求，都分配一个子任务。
2. 将 TcpStream 转换为 Framed。
3. 创建了一个消息通道，用于从客户端读取数据并发送给写任务。
4. 创建第一个异步子任务，从客户端读取数据，然后发送给消息通道。
5. 创建第二个异步子任务，从消息通道读取消息，然后向客户端写入数据。
6. 子任务 loop，终止条件是客户端没有消息了。



### 四、网络 IO-自定义编码解码

自定义 HexCodec，实现一个简单的协议，协议格式如下：

```
报文最少长度14字节：  设备地址（6）+ 信息ID（2）+ 功能编码（1）+ 长度（2）+ 最小数据（1）+ CRC（2）
例子：AA AA AA AA AA AA + BB BB + CC + DD DD + EE + FF FF
```

参考项目 [tokio_test](https://github.com/Cocola6s6/rust_demo/tree/master/tokio_testhttps://github.com/Cocola6s6/rust_demo/tree/master/tokio_test)
